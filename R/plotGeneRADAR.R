#' @title plotGene
#' @param IP_BAM The bam files for IP samples
#' @param INPUT_BAM The bam files for INPUT samples
#' @param size.IP The size factor for IP libraries
#' @param size.INPUT The size factor for INPUT libraries
#' @param geneName The name (as defined in gtf file) of the gene you want to plot
#' @param geneModel The gene model generated by gtfToGeneModel() function
#' @param libraryType "opposite" for mRNA stranded library, "same" for samll RNA library
#' @param GTF gtf annotation as GRanges object. Can be obtained by GTF <- rtracklayer::import("xxx.gtf",format = "gtf")
#' @export
## the main function to plot m6A-seq on one group of data
plotGene <- function(IP_BAM, INPUT_BAM, size.IP, size.INPUT, geneName, geneModel, libraryType = "opposite", center = mean ,GTF,ZoomIn=NULL){
  IP.cov <- getAveCoverage(geneModel= geneModel,bamFiles = IP_BAM,geneName = geneName,size.factor = size.IP, libraryType = libraryType, center = center, ZoomIn = ZoomIn)
  INPUT.cov <- getAveCoverage(geneModel= geneModel,bamFiles = INPUT_BAM,geneName = geneName,size.factor = size.INPUT, libraryType = libraryType, center = center,ZoomIn = ZoomIn)
  cov.data <- data.frame(IP=IP.cov,Input=INPUT.cov,genome_location=as.numeric(names(IP.cov) ) )
  yscale <- max(IP.cov,INPUT.cov)
  p1 <- "ggplot(data = cov.data,aes(genome_location))+geom_line(aes(y=Input,colour =\"Input\"))+geom_line(aes(y=IP,colour=\"IP\"))+labs(y=\"normalized coverage\")+scale_x_continuous(breaks = round(seq(min(cov.data$genome_location), max(cov.data$genome_location), by = ((max(cov.data$genome_location)-min(cov.data$genome_location))/10) ),1))+
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_line(colour = \"black\"))"
  
  p2 <- .getGeneModelAnno(geneModel,geneName,GTF,ZoomIn)
  p <- paste(p1,p2,sep = "+")
  eval(parse( text = p ))
}

## the main function to plot m6A-seq on two group of data
#' @title plotGenePair
#' @description plot tow groups of samples in the same figure
#' @param Ctl_IP_BAM The bam files for Control IP samples
#' @param Ctl_INPUT_BAM The bam files for Control INPUT samples
#' @param Treat_IP_BAM The bam files for treated IP samples
#' @param Treat_INPUT_BAM The bam files for treated INPUT samples
#' @param Ctl_size.IP The size factor for IP libraries
#' @param Ctl_size.INPUT The size factor for INPUT libraries
#' @param Treat_size.IP The size factor for IP libraries
#' @param Treat_size.INPUT The size factor for INPUT libraries
#' @param geneName The name (as defined in gtf file) of the gene you want to plot
#' @param geneModel The gene model generated by gtfToGeneModel() function
#' @param libraryType "opposite" for mRNA stranded library, "same" for samll RNA library
#' @export
plotGenePair <- function(Ctl_IP_BAM,Ctl_INPUT_BAM,Treat_IP_BAM,Treat_INPUT_BAM,Ctl_size.IP,Ctl_size.INPUT,Treat_size.IP,Treat_size.INPUT,geneName,geneModel, libraryType = "ooposite",center = mean, GTF ,ZoomIn=NULL){
  Ctl_IP.cov <- getAveCoverage(geneModel= geneModel,bamFiles = Ctl_IP_BAM,geneName = geneName,size.factor = Ctl_size.IP, libraryType = libraryType,center = center, ZoomIn = ZoomIn)
  Ctl_INPUT.cov <- getAveCoverage(geneModel= geneModel,bamFiles = Ctl_INPUT_BAM,geneName = geneName,size.factor = Ctl_size.INPUT,libraryType = libraryType, center = center , ZoomIn = ZoomIn)
  Treat_IP.cov <- getAveCoverage(geneModel= geneModel,bamFiles = Treat_IP_BAM,geneName = geneName,size.factor = Treat_size.IP, libraryType = libraryType, center = center,ZoomIn = ZoomIn)
  Treat_INPUT.cov <- getAveCoverage(geneModel= geneModel,bamFiles = Treat_INPUT_BAM,geneName = geneName,size.factor = Treat_size.INPUT, libraryType = libraryType, center = center,ZoomIn = ZoomIn)
  cov.data <- data.frame(Ctl_IP=Ctl_IP.cov, Ctl_Input = Ctl_INPUT.cov,
                         Treat_IP=Treat_IP.cov, Treat_Input = Treat_INPUT.cov,
                         genome_location=as.numeric(names(Ctl_IP.cov) ) )
  yscale <- max(Ctl_IP.cov,Ctl_INPUT.cov,Treat_IP.cov,Treat_INPUT.cov)
  p1 <- "ggplot(data = cov.data,aes(genome_location))+geom_line(aes(y=Ctl_Input,colour =\"Ctl Input\"))+geom_line(aes(y=Treat_IP,colour=\"Treat IP\"))+geom_line(aes(y=Treat_Input,colour =\"Treat Input\"))+geom_line(aes(y=Ctl_IP,colour=\"Ctl IP\"))+labs(y=\"normalized coverage\")+scale_x_continuous(breaks = round(seq(min(cov.data$genome_location), max(cov.data$genome_location), by = ((max(cov.data$genome_location)-min(cov.data$genome_location))/10) ),1))+
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_line(colour = \"black\"))"
  p2 <- .getGeneModelAnno(geneModel,geneName,GTF,ZoomIn)
  p <- paste(p1,p2,sep = "+")
  eval(parse( text = p ))
  
}

## helper function to get average coverage of a gene of multiple samples
getAveCoverage <- function(geneModel,bamFiles,geneName,size.factor, libraryType = libraryType, center ,ZoomIn){
  locus <- as.data.frame( range(geneModel[geneName][[1]]) )
  if(is.null(ZoomIn)){
  }else{
    locus$start = ZoomIn[1]
    locus$end = ZoomIn[2]
    locus$width = ZoomIn[2] - ZoomIn[1] + 1
  }
  covs <- sapply(bamFiles,getCov,locus=locus, libraryType = libraryType)
  covs <- t( t(covs)/size.factor )
  ave.cov <- apply(covs,1, center)
  return(ave.cov)
}

getCov <- function(bf,locus, libraryType ){
  s_param <- ScanBamParam(which = GRanges(locus$seqnames,IRanges(locus$start,locus$end)))
  p_param <- PileupParam(max_depth=1000000,min_nucleotide_depth=0,distinguish_nucleotides=F)
  #get coverage from the bam file
  res <- pileup(bf,scanBamParam = s_param,pileupParam = p_param)
  if(libraryType == "opposite"){
    res <- res[res$strand!=locus$strand,]
  }else if (libraryType == "same"){
    res <- res[res$strand==locus$strand,]
  }else{
    stop("libraryType must be opposite or same... ")
  }
  cov <- vector(length = locus$width)
  names(cov) <- c(locus$start:locus$end)
  cov[1:locus$width] <- 0
  cov[res$pos-locus$start+1] <- res$count
  return(cov)
}


.getGeneModelAnno <- function(geneModel,geneName,gtf_grange,zoomIn = NULL){
  exon.current <- reduce( geneModel[geneName][[1]] )
  startCodon <-  reduce( gtf_grange[gtf_grange$type == "start_codon" & gtf_grange$gene_id == geneName] )
  stopCodon <- reduce( gtf_grange[gtf_grange$type == "stop_codon" & gtf_grange$gene_id == geneName] )
  ## remove non_cononical seq_level
  startCodon <- keepSeqlevels(startCodon, seqlevels(exon.current), pruning.mode = "coarse")
  stopCodon <- keepSeqlevels(stopCodon, seqlevels(exon.current), pruning.mode = "coarse")
  if(as.logical(strand(exon.current)[1]=="-")){
    startCodon <- startCodon[which.max( start(startCodon) )]
    stopCodon <- stopCodon[which.min( start(stopCodon) )]
    cdsRange <- stopCodon
    end(cdsRange) <- end(startCodon)
    cds.current <- suppressWarnings( GenomicRanges::intersect(exon.current,cdsRange) )
  }else{
    startCodon <- startCodon[which.min( start(startCodon) )]
    stopCodon <- stopCodon[which.max( start(stopCodon) )]
    cdsRange <- startCodon
    end(cdsRange) <- end(stopCodon)
    cds.current <- suppressWarnings( GenomicRanges::intersect(exon.current,cdsRange) )
  }
  utr.current <- GenomicRanges::setdiff(exon.current,cds.current)
  exon.new <- sort( c(cds.current,utr.current) )
  
  if(is.null(zoomIn)){
    cds.id <- unique( queryHits( findOverlaps(exon.new, cds.current)) )
    df.exon <- as.data.frame(exon.new)
    anno.exon <- character(length = length(exon.new))
    anno.intron <- character(length = length(exon.new)-1 )
    for(i in 1:length(exon.new)){
      if( i %in% cds.id){
        anno.exon[i] <- paste0("annotate(\"rect\", xmin =",df.exon$start[i] ,", xmax = ",df.exon$end[i] ,", ymin = -0.08*yscale, ymax = -0.02*yscale, alpha = .99, colour = \"black\")" )
      }else{
        anno.exon[i] <- paste0("annotate(\"rect\",xmin =",df.exon$start[i] ,", xmax = ",df.exon$end[i] ,", ymin = -0.06*yscale, ymax = -0.04*yscale, alpha = .99, colour = \"black\")")
      }
    }
    if(length(anno.intron)>0){
      for(i in 1:length(anno.intron)){
        anno.intron[i] <- paste0("annotate(\"segment\", x =", df.exon$end[i] ,", xend =", df.exon$start[i+1] ,", y = -0.05*yscale, yend = -0.05*yscale, alpha = .99, colour = \"black\")")
      }
    }
    p <- paste( paste(anno.exon,collapse = "+"), paste(anno.intron,collapse = "+"), sep = "+")
    
    return(p)
    
  }else{
    zoomIn.gr <- cdsRange
    ranges(zoomIn.gr) <- IRanges(start = zoomIn[1],end = zoomIn[2])
    exon.zoom <- GenomicRanges::intersect(exon.new, zoomIn.gr)
    cds.current.zoom <- GenomicRanges::intersect(exon.zoom, cds.current)
    utr.current.zoom <- GenomicRanges::setdiff(exon.zoom,cds.current.zoom)
    exon.zoom.new <-  sort( c(cds.current.zoom,utr.current.zoom) )
    
    cds.id <- unique( queryHits( findOverlaps(exon.zoom.new, cds.current.zoom)) )
    df.exon <- as.data.frame(exon.zoom.new)
    anno.exon <- character(length = length(exon.zoom))
    for(i in 1:length(exon.zoom.new)){
      if( i %in% cds.id){
        anno.exon[i] <- paste0("annotate(\"rect\", xmin =",df.exon$start[i] ,", xmax = ",df.exon$end[i] ,", ymin = -0.08*yscale, ymax = -0.02*yscale, alpha = .99, colour = \"black\")" )
      }else{
        anno.exon[i] <- paste0("annotate(\"rect\",xmin =",df.exon$start[i] ,", xmax = ",df.exon$end[i] ,", ymin = -0.06*yscale, ymax = -0.04*yscale, alpha = .99, colour = \"black\")")
      }
    }
    anno.intron <- character(length = length(exon.zoom.new)-1 )
    if(length(anno.intron)>0){
      for(i in 1:length(anno.intron)){
        anno.intron[i] <- paste0("annotate(\"segment\", x =", df.exon$end[i] ,", xend =", df.exon$start[i+1] ,", y = -0.05*yscale, yend = -0.05*yscale, alpha = .99, colour = \"black\")")
      }
    }
    if(start(zoomIn.gr)<start(exon.zoom)[1]){
      anno.intron <- c(paste0("annotate(\"segment\", x =", start(zoomIn.gr) ,", xend =", start(exon.zoom)[1] ,", y = -0.05*yscale, yend = -0.05*yscale, alpha = .99, colour = \"black\")"),
                       anno.intron)
    }
    if(end(zoomIn.gr) > end(exon.zoom)[length(exon.zoom)]){
      anno.intron <- c(anno.intron,
                       paste0("annotate(\"segment\", x =", end(exon.zoom)[length(exon.zoom)] ,", xend =", end(zoomIn.gr) ,", y = -0.05*yscale, yend = -0.05*yscale, alpha = .99, colour = \"black\")") )
    }
    if( length(anno.intron) > 0 ){
      p <- paste( paste(anno.exon,collapse = "+"), paste(anno.intron,collapse = "+"), sep = "+")
    }else{
      p <- paste(anno.exon,collapse = "+")
    }
    
    return(p)
  }
  
}


#' @title plotGeneMonster
#' @param readsOut The data list from countReads and other analysis.
#' @param geneName The gene symbol to be ploted.
#' @param GTF The GRanges object containing gtf annotation.
#' @param ZoomIn c(start,end) The coordinate to zoom in at the gene to be ploted.
#' @export
plotGeneRADAR <- function(readsOut, geneName, libraryType = "opposite", center = "mean", GTF, ZoomIn = NULL){
  if("X" %in% names(readsOut) ){
    X <- readsOut$X
    plotGenePair(Ctl_IP_BAM = readsOut$bamPath.ip[X == unique(X)[1]],
                 Ctl_INPUT_BAM = readsOut$bamPath.input[X == unique(X)[1]],
                 Treat_IP_BAM = readsOut$bamPath.ip[X == unique(X)[2]],
                 Treat_INPUT_BAM = readsOut$bamPath.input[X == unique(X)[2]],
                 Ctl_size.IP = readsOut$sizeFactor$ip[X == unique(X)[1]],
                 Ctl_size.INPUT = readsOut$sizeFactor$input[X == unique(X)[1]],
                 Treat_size.IP = readsOut$sizeFactor$ip[X == unique(X)[2]],
                 Treat_size.INPUT = readsOut$sizeFactor$input[X == unique(X)[2]],
                 geneName = geneName,
                 geneModel = readsOut$geneModel,
                 libraryType = libraryType,center = center,GTF = GTF,ZoomIn = ZoomIn )
  }else{
    plotGene(IP_BAM = readsOut$bamPath.ip,
             INPUT_BAM =  readsOut$bamPath.input,
             size.IP = readsOut$sizeFactor$ip,
             size.INPUT = readsOut$sizeFactor$input,
             geneName = geneName,
             geneModel = readsOut$geneModel,
             libraryType = libraryType,center = center,GTF = GTF,ZoomIn = ZoomIn)
  }
}
